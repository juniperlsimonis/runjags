# with explicit control over the random number
# generator used for each chain (optional):
data <- list(X=X, Y=Y, N=length(X))
inits1 <- list(m=1, c=1, precision=1,
.RNG.name="base::Super-Duper", .RNG.seed=1)
inits2 <- list(m=0.1, c=10, precision=1,
.RNG.name="base::Wichmann-Hill", .RNG.seed=2)
## Not run:
# Run the model and produce plots
results <- run.jags(model=model, monitor=c("m", "c", "precision"),
data=data, n.chains=2, method="rjags", inits=list(inits1,inits2))
n.chains <- coda::nchain(thinnedmcmclist)
n.iter <- coda::niter(thinnedmcmclist)
n.var <- coda::nvar(thinnedmcmclist)
# 1 iteration + 1 chain is handled by normalise.mcmcfun:
normalised <- normalise.mcmcfun(thinnedmcmclist, normalise = normalise.mcmc, warn=TRUE, remove.nonstochastic = TRUE)
normalisedmcmc <- normalised$mcmc
truestochastic <- normalised$truestochastic
semistochastic <- normalised$semistochastic
nonstochastic <- normalised$nonstochastic
collapsed <- combine.mcmc(thinnedmcmclist, collapse.chains=TRUE)
options(show.error.messages = FALSE)
success <- try({
suppressWarnings(tsummary <- summary(combine.mcmc(thinnedmcmclist, collapse.chains=FALSE)))
if(is.numeric(tsummary$statistics)){
tsummary$statistics <- t(as.matrix(tsummary$statistics))
#dimnames(tsummary$statistics)[[1]] <- varnames(thinnedmcmclist)
tsummary$quantiles <- t(as.matrix(tsummary$quantiles))
#dimnames(tsummary$quantiles)[[1]] <- varnames(thinnedmcmclist)
}
})
if(inherits(success, 'try-error')) tsummary <- "An unexpected error occured while calculating summary statistics"
se
sqrt(sseff)
tsummary$statistics
suppressWarnings(tsummary <- summary(combine.mcmc(thinnedmcmclist, collapse.chains=FALSE)))
tsummary
class(tsummary)
is.numeric(tsummary$statistics)
class(tsummary$statistics)
dim(tsummary$statistics)
dim(1:10)
library(runjags)
results <- run.jags(model=model, monitor=c("m", "c", "precision"),
data=data, n.chains=2, method="rjags", inits=list(inits1,inits2))
library(runjags)
if(require(rjags)){
load.module('dic')
}
library(parallel)
testjags()
runjags.options(inits.warning=FALSE, rng.warning=FALSE, blockignore.warning=FALSE, blockcombine.warning=FALSE, silent.jags=TRUE, silent.runjags=TRUE)
filestring <- "
Poisson model...
model {
for (i in 1:6) {
for (j in 1:3) {
y[i,j] ~ dpois(mu[i])
}
log(mu[i]) <- alpha + beta*log(x[i] + 10) + gamma*x[i]
}
for (i in 1:6) {
y.pred[i] ~ dpois(mu[i])
}
alpha ~ dnorm(0, 0.0001)
beta ~ dnorm(0, 0.0001)
gamma ~ dnorm(0, 0.0001)
}
Data{
list(y = structure(.Data = c(15,21,29,16,18,21,16,26,33,
27,41,60,33,38,41,20,27,42),
.Dim = c(6, 3)),
x = c(0, 10, 33, 100, 333, 1000))
}
Inits{
list(alpha = 0, beta = 1, gamma = -0.1)
}
Inits{
list(alpha = 10, beta = 0, gamma = 0.1)
}
"
results <- run.jags(filestring, monitor=c('alpha','beta','gamma'))
library(runjags)
library(runjags)
source('~/Documents/GitHub/runjags/tests/checkmethods.R')
library(runjags)
runjags.options(inits.warning=FALSE, rng.warning=FALSE, blockignore.warning=FALSE, silent.jags=TRUE)
# Require for as.mcmc.list and niter:
library("coda")
model <- "model {
for(i in 1 : N){ #data# N
Y[i] ~ dnorm(true.y[i], precision); #data# Y
true.y[i] <- (m * X[i]) + c; #data# X
}
m ~ dunif(-1000,1000); #inits# m
c ~ dunif(-1000,1000);
precision ~ dexp(1);
#monitor# m, c, precision, dic, full.pd, popt, pd
}"
# Simulate the data
X <- 1:100
Y <- rnorm(length(X), 2*X + 10, 1)
N <- length(X)
initfunction <- function(chain) return(switch(chain, "1"=list(m=-10), "2"=list(m=10)))
# Get the JAGS path - rjags adds the JAGS path to the PATH in Windows...
try(library(rjags))
jagspath <- findjags()
testnum <- 1
cat('Testing the simple method\n')
# Try the simple method and if it doesn't work give a warning but don't fail (likely to be permissions problems)
success <- try({
results <- run.jags(model, n.chains=2, sample=1000, burnin=1000, inits=initfunction, method='simple',temp=FALSE)
})
if(inherits(success, 'try-error')){
cat("JAGS was found but the simple method failed; it is possible that there were permissions issues or similar.  Details as follows:\n")
t <- testjags(silent=FALSE)
cat(failed.jags('output')[[1]])
print(file.info(jagspath))
print(file.info(getwd())[,1:3])
cat("All test methods (except possibly rjags) were skipped\n")
}else{
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
stopifnot(niter(as.mcmc.list(results))==1000)
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results <- run.jags(model, n.chains=2, sample=1000, burnin=1000, inits=initfunction, method='parallel')
stopifnot(niter(as.mcmc.list(results))==1000)
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results <- run.jags(model, n.chains=2, sample=1000, burnin=1000, inits=initfunction, method='interruptible')
stopifnot(niter(as.mcmc.list(results))==1000)
# Same as in checkinputs but it's for rjags there:
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results2 <- extend.jags(results, sample=1000, add.monitor="true.y", summarise=FALSE)
stopifnot(nvar(as.mcmc.list(results2))==(3+N))
stopifnot(varnames(as.mcmc.list(results2))[1]=='m' && varnames(as.mcmc.list(results2))[103]=='true.y[100]')
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results2 <- extend.jags(results, sample=1000, add.monitor=c("true.y", "dic"), summarise=FALSE)
stopifnot(nvar(as.mcmc.list(results2))==(3+N))
stopifnot(varnames(as.mcmc.list(results2))[1]=='m' && varnames(as.mcmc.list(results2))[103]=='true.y[100]')
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results2 <- extend.jags(results, sample=1000, add.monitor=c("true.y", "deviance"), summarise=FALSE)
stopifnot(nvar(as.mcmc.list(results2))==(4+N))
stopifnot(varnames(as.mcmc.list(results2))[1]=='m' && varnames(as.mcmc.list(results2))[104]=='deviance')
# Same as in checkinputs but it's for rjags there:
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results2 <- extend.jags(results, sample=1000, add.monitor="true.y", summarise=FALSE, method='simple')
stopifnot(nvar(as.mcmc.list(results2))==(3+N))
stopifnot(varnames(as.mcmc.list(results2))[1]=='m' && varnames(as.mcmc.list(results2))[103]=='true.y[100]')
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results2 <- extend.jags(results, sample=1000, add.monitor=c("true.y", "dic"), summarise=FALSE)
stopifnot(nvar(as.mcmc.list(results2))==(3+N))
stopifnot(varnames(as.mcmc.list(results2))[1]=='m' && varnames(as.mcmc.list(results2))[103]=='true.y[100]')
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results2 <- extend.jags(results, sample=1000, add.monitor=c("true.y", "deviance"), summarise=FALSE)
stopifnot(nvar(as.mcmc.list(results2))==(4+N))
stopifnot(varnames(as.mcmc.list(results2))[1]=='m' && varnames(as.mcmc.list(results2))[104]=='deviance')
# Snow gives problems here ... but it does work!
#results <- run.jags(model, n.chains=2, sample=1000, burnin=1000, inits=initfunction, method='snow')
#stopifnot(niter(as.mcmc.list(results))==1000)
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
info <- run.jags(model, n.chains=2, sample=1000, burnin=1000, inits=initfunction, method='background')
t <- 0
repeat{
# Change thin, chain and variables:
s <- try(results <- results.jags(info, read.monitor='m', return.samples=100, recover.chains=2, summarise=FALSE))
if(class(s)!='try-error') break
if(t==30) stop("Timed out waiting for the bgparallel method")
Sys.sleep(1)
t <- t+1
}
stopifnot(niter(as.mcmc.list(results))==100)
stopifnot(nvar(as.mcmc.list(results))==1)
stopifnot(nchain(as.mcmc.list(results))==1)
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
info <- run.jags(model, n.chains=2, sample=1000, burnin=1000, inits=initfunction, method='bgparallel')
t <- 0
repeat{
s <- try(results <- results.jags(info))
if(class(s)!='try-error') break
if(t==30) stop("Timed out waiting for the bgparallel method")
Sys.sleep(1)
t <- t+1
}
stopifnot(niter(as.mcmc.list(results))==1000)
# Check combine.mcmc does what it says on the tin:
stopifnot(niter(combine.mcmc(results, return.samples=1000, collapse.chains=TRUE))==1000)
stopifnot(niter(combine.mcmc(results, return.samples=11, collapse.chains=TRUE))==11)
stopifnot(niter(combine.mcmc(results, return.samples=100, collapse.chains=FALSE))==100)
stopifnot(niter(combine.mcmc(results, thin=1, collapse.chains=TRUE))==2000)
stopifnot(niter(combine.mcmc(results, thin=10, collapse.chains=TRUE))==200)
stopifnot((niter(combine.mcmc(results, thin=15, collapse.chains=TRUE))*15)>=2000)
stopifnot(niter(combine.mcmc(results, thin=10, collapse.chains=FALSE))==100)
# Check we can use the extend wrapper:
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
newres <- extend.jags(results, sample=0)
stopifnot(newres$burnin==results$burnin)
stopifnot(niter(as.mcmc.list(newres))==niter(as.mcmc.list(results)))
# Check a single iteration works:
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results <- run.jags(model, n.chains=2, sample=1, burnin=1000, inits=initfunction, method='interruptible', summarise=FALSE)
stopifnot(niter(as.mcmc.list(results))==1)
# And that precision can be ignored:
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results <- run.jags(model, monitor=c('m','c'), n.chains=2, sample=10, burnin=100, inits=initfunction, method='interruptible', summarise=FALSE, noread.monitor='precision')
stopifnot(nvar(as.mcmc.list(results))==2)
# Check the version number is correct:
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
stopifnot(newres$runjags.version[1]==runjags:::runjagsprivate$runjagsversion)
}
testnum <- 1
cat('Testing the simple method\n')
# Try the simple method and if it doesn't work give a warning but don't fail (likely to be permissions problems)
success <- try({
results <- run.jags(model, n.chains=2, sample=1000, burnin=1000, inits=initfunction, method='simple',temp=FALSE)
})
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
stopifnot(niter(as.mcmc.list(results))==1000)
cat('Running method test number', testnum, '\n'); testnum <- testnum+1
results <- run.jags(model, n.chains=2, sample=1000, burnin=1000, inits=initfunction, method='parallel')
model
source('~/Documents/GitHub/runjags/tests/checkmethods.R')
source('~/Documents/GitHub/runjags/tests/checkmethods.R')
source('~/Documents/GitHub/runjags/tests/checkmethods.R')
library(runjags)
#' @rdname runjags.options
#' @export
runjags.options <- function(...){
opts <- list(...)
# For backwards compatibility:
if(any(names(opts)=='newwindows')){
opts$new.windows <- opts$newwindows
opts$newwindows <- NULL
}
if(length(opts)>0){
options <- runjagsprivate$options
recognised <- pmatch(names(opts), names(options))
if(any(is.na(recognised))){
warning(paste("Igoring unmatched or ambiguous option(s): ", paste(names(opts)[is.na(recognised)],collapse=", ")))
opts <- opts[!is.na(recognised)]
}
optnames <- names(options)[recognised[!is.na(recognised)]]
if(length(optnames)>0) for(i in 1:length(optnames)){
options[optnames[i]] <- opts[[i]]
}
assign("options",options,envir=runjagsprivate)
}
# Some checks for valid option settings:
if((!is.numeric(runjags.getOption('plot.layout')) || length(runjags.getOption('plot.layout'))!=2))
stop('The "plot.layout" option must be a numeric vector of length 2')
runjagsprivate$options$adapt.incomplete <- c('error','warning','silent')[pmatch(runjagsprivate$options$adapt.incomplete,c('error','warning','silent'))]
if(is.na(runjagsprivate$options$adapt.incomplete))
stop('The "adapt.incomplete" option must be either error, warning or silent')
invisible(runjagsprivate$options)
}
#' @rdname testjags
#' @export
testjags <- function(jags=runjags.getOption('jagspath'), silent=FALSE){
# Evaluate jags outside a suppresswarnings:
jags <- jags
tempfile <- new_unique(name=tempfile("test"), suffix=".cmd", touch=TRUE, type='file')
write("exit", file=tempfile)
s.info <- Sys.info()
p.info <- .Platform
os <- p.info$OS.type
username <- as.character(s.info["user"])
rversion <- R.version$version
gui <- p.info$GUI
p.type <- p.info$pkgType
libpaths <- NULL
if(os=="windows"){
if(file.exists(paste(jags, 'bin', .Platform$file.sep, 'jags-terminal.exe', sep=''))) jags <- paste(jags, 'bin/jags-terminal.exe', sep='')
if(file.exists(paste(jags, .Platform$file.sep, 'bin', .Platform$file.sep, 'jags-terminal.exe', sep=''))) jags <- paste(jags, '/bin/jags-terminal.exe', sep='')
if(file.exists(paste(jags, 'jags-terminal.exe', sep=''))) jags <- paste(jags, 'jags-terminal.exe', sep='')
if(file.exists(paste(jags, .Platform$file.sep, 'jags-terminal.exe', sep=''))) jags <- paste(jags, '/jags-terminal.exe', sep='')
path <- strsplit(jags, split=paste(.Platform$file.sep, 'bin', sep=''), fixed=TRUE)
firstpath <- path[[1]][1:length(path[[1]])-1]
binpath <- paste(firstpath, .Platform$file.sep, 'bin;', sep='')
libpath <- paste(firstpath, .Platform$file.sep, 'modules;', sep='')
libpaths <- list(PATH=binpath, LTDL_LIBRARY_PATH=libpath)
}
suppressWarnings(returnval <- try(system2(jags, args=tempfile, stdout=TRUE, stderr=TRUE), silent=TRUE))
unlink(tempfile)
if(class(returnval)=="try-error"){
success <- 0
}else{
if(is.null(attributes(returnval))){
success <- 1
}else{
success <- -1
}
}
if(length(returnval)==0){
success <- 0
#		warning(paste("Running the command ", jags, " returned no output - ensure the path is correct and possibly try reinstalling jags\n", sep=""))
}
if(!any(grepl("Welcome",returnval))){
success <- 0
#		warning(paste("Running the command ", jags, " did not return the expected welcome message - ensure the path is correct and possibly try reinstalling jags\n", sep=""))
}
if(success){
rightstring <- which(grepl("Welcome",returnval))[1]
if(is.na(rightstring)){  # Will be NA if which is length 0 as selected first element above
version <- 'unknown'
num.version <- NA
}else{
version <- strsplit(returnval[rightstring], split=" ", fixed=TRUE)[[1]][4]
versioncom <- version
if(grepl('(', versioncom, fixed=TRUE)){
versioncom <- strsplit(versioncom, split='(', fixed=TRUE)[[1]][1]
}
versioncom <- sub('.',';',versioncom,fixed=TRUE)
versioncom <- gsub('.','',versioncom,fixed=TRUE)
num.version <- as.numeric(gsub(';','.',versioncom,fixed=TRUE))
if(is.na(version)) version <- 'unknown'
}
}
if(any(.packages(TRUE)=="rjags")){
rjags.avail <- TRUE
rjags.major <- packageVersion('rjags')$major
rjags.version <- packageDescription('rjags', fields='Version')
}else{
rjags.avail <- FALSE
rjags.major <- 0
rjags.version <- ""
}
if(!silent)
swcat("You are using ", rversion, " on a ", os, " machine, with the ", gui, " GUI\n", sep="")
if(jags=="JAGS not found") jags <- "findjags()"
jags.major <- NA
if(success){
if(success==-1){
if(!silent) suppressWarnings(swcat("JAGS version ", version, " found successfully using the command '", jags, "', but returned the status code '", attributes(returnval)$status, "' - this may indicate a compatibility issue, procede with caution\n", sep=""))
}else{
if(!silent) suppressWarnings(swcat("JAGS version ", version, " found successfully using the command '", jags, "'\n", sep=""))
}
if(!is.na(num.version) & num.version<1){
warning(paste("The version of JAGS currently installed on your system is no longer supported.  Please update JAGS from http://mcmc-jags.sourceforge.net\n"))
jags.avail <- FALSE
}else{
jags.avail <- TRUE
}
jagsfound <- TRUE
jags.major <- floor(num.version)
}else{
if(rjags.avail){
if(!silent) suppressWarnings(swcat("JAGS was not found on your system using the command '", jags, "'.  Please ensure that the command is correct and that the latest version of JAGS is installed from http://mcmc-jags.sourceforge.net\n", sep=""))
jags.avail <- TRUE
# If it's just rjags assume the version number is high enough:
num.version <- Inf
jags.major <- NA
}else{
if(!silent) suppressWarnings(swcat("JAGS was not found on your system using the command '", jags, "'.  Please ensure that the command is correct.\n", sep=""))
jags.avail <- FALSE
num.version <- "none found"
jags.major <- NA
}
if(gui %in% c('RStudio', 'AQUA') && !silent)
swcat("Note that as of OS X Yosemite, the FULL path must be provided to JAGS as the $PATH global variable is not passed to processes started from within a GUI application\n", sep="")
jagsfound <- FALSE
}
if(rjags.avail && num.version < Inf){  # If rjags and JAGS are both findable independently
if(success!=0 && rjags.major!=floor(num.version)){   # If JAGS is installed and rjags major != JAGS major
if(!silent)
swcat("The rjags package version ", rjags.major, ".x is installed, but this is not compatible with your installed version of JAGS (version ", floor(num.version), ".x)\n",sep="")
if(rjags.major > num.version){
msg <- paste("You should update to JAGS version ", rjags.major, ".x from https://sourceforge.net/projects/mcmc-jags/files/JAGS/", sep="")
}else{
msg <- paste("You should update the rjags package to version ", floor(num.version), ".x - if the version on CRAN is not currently up to date, try downloading from https://sourceforge.net/projects/mcmc-jags/files/rjags/ instead", sep="")
}
if(!silent)
swcat(msg,"\n")
if(!runjagsprivate$warned_version_mismatch){
warning(paste(msg, "\n(This warning is given once per R session)"), call. =FALSE)
runjagsprivate$warned_version_mismatch <- TRUE
}
}else if(!silent){
swcat("The rjags package is installed\n",sep="")
}
}else if(rjags.avail && num.version == Inf && !silent){
swcat("The rjags package version ", rjags.major, ".x is installed (compatibility with the major version of JAGS cannot be verified)\n",sep="")
}else if(!rjags.avail && !silent){
swcat("The rjags package is not installed\n",sep="")
}
invisible(list("os"=os, "JAGS.available"=jags.avail, "JAGS.found"=jagsfound, "rjags.found"=rjags.avail, "rjags.version"=rjags.version, "rjags.major"=rjags.major, "JAGS.path"=jags, "JAGS.version"=version, "JAGS.major"=jags.major, "R.version"=rversion, "R.GUI"=gui, "R.package.type"=p.type, "username"=username, libpaths=libpaths))
}
testjags('some/jags/path')
library(runjags)
if(require(rjags)){
load.module('dic')
}
library(parallel)
testjags()
library(runjags)
if(require(rjags)){
load.module('dic')
}
library(parallel)
testjags()
runjags.options(inits.warning=FALSE, rng.warning=FALSE, blockignore.warning=FALSE, blockcombine.warning=FALSE, silent.jags=TRUE, silent.runjags=TRUE)
filestring <- "
Poisson model...
model {
for (i in 1:6) {
for (j in 1:3) {
y[i,j] ~ dpois(mu[i])
}
log(mu[i]) <- alpha + beta*log(x[i] + 10) + gamma*x[i]
}
for (i in 1:6) {
y.pred[i] ~ dpois(mu[i])
}
alpha ~ dnorm(0, 0.0001)
beta ~ dnorm(0, 0.0001)
gamma ~ dnorm(0, 0.0001)
}
Data{
list(y = structure(.Data = c(15,21,29,16,18,21,16,26,33,
27,41,60,33,38,41,20,27,42),
.Dim = c(6, 3)),
x = c(0, 10, 33, 100, 333, 1000))
}
Inits{
list(alpha = 0, beta = 1, gamma = -0.1)
}
Inits{
list(alpha = 10, beta = 0, gamma = 0.1)
}
"
results <- run.jags(filestring, monitor=c('alpha','beta','gamma'))
library(runjags)
if(require(rjags)){
load.module('dic')
}
library(parallel)
testjags()
runjags.options(inits.warning=FALSE, rng.warning=FALSE, blockignore.warning=FALSE, blockcombine.warning=FALSE, silent.jags=TRUE, silent.runjags=TRUE)
filestring <- "
Poisson model...
model {
for (i in 1:6) {
for (j in 1:3) {
y[i,j] ~ dpois(mu[i])
}
log(mu[i]) <- alpha + beta*log(x[i] + 10) + gamma*x[i]
}
for (i in 1:6) {
y.pred[i] ~ dpois(mu[i])
}
alpha ~ dnorm(0, 0.0001)
beta ~ dnorm(0, 0.0001)
gamma ~ dnorm(0, 0.0001)
}
Data{
list(y = structure(.Data = c(15,21,29,16,18,21,16,26,33,
27,41,60,33,38,41,20,27,42),
.Dim = c(6, 3)),
x = c(0, 10, 33, 100, 333, 1000))
}
Inits{
list(alpha = 0, beta = 1, gamma = -0.1)
}
Inits{
list(alpha = 10, beta = 0, gamma = 0.1)
}
"
results <- run.jags(filestring, monitor=c('alpha','beta','gamma'))
results
plot(results, layout=c(3,4), file='plots.pdf', height=10, width=8)
plot(results, layout=c(3,4))
resultswithglm <- run.jags(filestring, monitor=c('alpha','beta','gamma'), modules='glm')
resultswithglm
# Simulate the data:
set.seed(1)
X <- 1:100
Y <- rnorm(length(X), 2*X + 10, 1)
N <- length(X)
model <- "
model {
for(i in 1 : N){ #data# N
Y[i] ~ dnorm(true.y[i], precision) #data# Y
true.y[i] <- (coef * X[i]) + int #data# X
}
coef ~ dunif(-1000,1000)
int ~ dunif(-1000,1000)
precision ~ dexp(1)
#inits# coef, int, precision
#monitor# coef, int, precision
}"
# A function to return initial values for each chain:
coef <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
int <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
precision <- function(chain) return(switch(chain, "1"= 0.01, "2"= 100))
# Run the simulation:
results <- run.jags(model, n.chains = 2)
results <- extend.jags(results, sample=5000)
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
D9 <- data.frame(weight, group)
# The JAGS equivalent:
model <- template.jags(weight ~ group, D9, n.chains=2, family='gaussian')
JAGS.D9 <- run.jags(model)
lm.D9 <- lm(weight ~ group, data=D9)
JAGS.D9
summary(lm.D9)
JAGS.D9 <- run.jags(model, mutate=list(prec2sd, 'precision'))
summary(JAGS.D9, vars=c('regression_precision.sd', 'intercept', 'group_effect'))
summary(residuals(lm.D9) - residuals(JAGS.D9, output='mean'))
extract(JAGS.D9, what='samplers')
citation('runjags')
sessionInfo()
install.packages("rmarkdown")
